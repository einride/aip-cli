package gengoaipcli

import (
	"fmt"
	"path"
	"strings"

	"go.einride.tech/aip-cli/aipcli"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoregistry"
)

const generateFilenameSuffix = "_cli.pb.go"

func Run(gen *protogen.Plugin, config Config) error {
	var files protoregistry.Files
	for _, file := range gen.Files {
		if err := files.RegisterFile(file.Desc); err != nil {
			return err
		}
	}
	if err := config.Validate(); err != nil {
		return err
	}
	for _, f := range gen.Files {
		if f.Generate {
			if err := generateFile(gen, &files, f); err != nil {
				return err
			}
		}
	}
	if config.Root != "" {
		if err := generateRootModuleFile(gen, config); err != nil {
			return err
		}
	}
	return nil
}

func generateRootModuleFile(gen *protogen.Plugin, config Config) error {
	module, ok := getModuleParam(gen)
	if !ok {
		return fmt.Errorf("param root requires param module to be provided")
	}
	g := gen.NewGeneratedFile(path.Join(module, config.RootPath, "root.go"), "")
	generateGeneratedFileHeader(g)
	g.P("package ", config.Root)
	cobraCommand := g.QualifiedGoIdent(protogen.GoIdent{
		GoImportPath: "github.com/spf13/cobra",
		GoName:       "Command",
	})
	cliConfig := g.QualifiedGoIdent(protogen.GoIdent{
		GoImportPath: "go.einride.tech/aip-cli/aipcli",
		GoName:       "Config",
	})
	aipCLINewModuleCommand := g.QualifiedGoIdent(protogen.GoIdent{
		GoImportPath: "go.einride.tech/aip-cli/aipcli",
		GoName:       "NewModuleCommand",
	})
	g.P()
	g.P("func NewModuleCommand(use string, short string, commands ...*", cobraCommand, ") *", cobraCommand, " {")
	g.P("config := NewConfig()")
	g.P("return ", aipCLINewModuleCommand, "(")
	g.P("use,")
	g.P("short,")
	g.P("config,")
	g.P("append(")
	g.P("[]*", cobraCommand, "{")
	for _, file := range gen.Files {
		if !file.Generate {
			continue
		}
		for _, service := range file.Services {
			newCommandFunction := g.QualifiedGoIdent(protogen.GoIdent{
				GoImportPath: file.GoImportPath,
				GoName:       "New" + service.GoName + "Command",
			})
			g.P(newCommandFunction, "(config),")
		}
	}
	g.P("},")
	g.P("commands...,")
	g.P(")...,")
	g.P(")")
	g.P("}")
	g.P()
	g.P("func NewConfig() ", cliConfig, "{")
	g.P("return ", fmt.Sprintf("%#v", aipcli.Config(config)))
	g.P("}")
	return nil
}

func getModuleParam(gen *protogen.Plugin) (string, bool) {
	for _, param := range strings.Split(gen.Request.GetParameter(), ",") {
		var value string
		if i := strings.Index(param, "="); i >= 0 {
			value = param[i+1:]
			param = param[0:i]
		}
		if param == "module" {
			return value, true
		}
	}
	return "", false
}

func generateFile(
	gen *protogen.Plugin,
	files *protoregistry.Files,
	file *protogen.File,
) error {
	g := gen.NewGeneratedFile(file.GeneratedFilenamePrefix+generateFilenameSuffix, file.GoImportPath)
	g.Skip()
	generateGeneratedFileHeader(g)
	g.P("package ", file.GoPackageName)
	for _, service := range file.Services {
		g.Unskip()
		if err := (newServiceCommandCodeGenerator{
			gen:     gen,
			files:   files,
			file:    file,
			service: service,
		}.generateCode(g)); err != nil {
			return err
		}
	}
	return nil
}

func generateGeneratedFileHeader(g *protogen.GeneratedFile) {
	g.P()
	g.P("// Code generated by protoc-gen-go-aip-cli. DO NOT EDIT.")
}
